import "./chunk-HKJ2B2AA.js";

// node_modules/cache-parser/dist/index.mjs
var e = Symbol("cache-parser");
function r(e3, r4) {
  (null == r4 || r4 > e3.length) && (r4 = e3.length);
  for (var t3 = 0, a2 = new Array(r4); t3 < r4; t3++) a2[t3] = e3[t3];
  return a2;
}
function t(e3) {
  return ("string" == typeof e3 || "number" == typeof e3) && (e3 = Number(e3)) >= 0 && e3 < Infinity;
}
function a(e3) {
  return true === e3 || "number" == typeof e3 || "string" == typeof e3 && "false" !== e3;
}
var n = Number;
function o(o2) {
  var i = Object.defineProperty({}, e, { enumerable: false, value: 1 });
  if (!o2 || "string" != typeof o2) return i;
  var s = (function(e3) {
    for (var t3, a2 = {}, n2 = (function(e4, t4) {
      var a3 = "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
      if (a3) return (a3 = a3.call(e4)).next.bind(a3);
      if (Array.isArray(e4) || (a3 = (function(e5, t5) {
        if (e5) {
          if ("string" == typeof e5) return r(e5, t5);
          var a4 = Object.prototype.toString.call(e5).slice(8, -1);
          return "Object" === a4 && e5.constructor && (a4 = e5.constructor.name), "Map" === a4 || "Set" === a4 ? Array.from(e5) : "Arguments" === a4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a4) ? r(e5, t5) : void 0;
        }
      })(e4))) {
        a3 && (e4 = a3);
        var n3 = 0;
        return function() {
          return n3 >= e4.length ? { done: true } : { done: false, value: e4[n3++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    })(e3.toLowerCase().replace(/\s+/g, "").split(",")); !(t3 = n2()).done; ) {
      var o3, i2 = t3.value.split("=", 2);
      a2[i2[0]] = null == (o3 = i2[1]) || o3;
    }
    return a2;
  })(o2), l = s["max-age"], u = s["max-stale"], m = s["min-fresh"], p = s["s-maxage"], f = s["stale-if-error"], c = s["stale-while-revalidate"];
  return a(s.immutable) && (i.immutable = true), t(l) && (i.maxAge = n(l)), t(u) && (i.maxStale = n(u)), t(m) && (i.minFresh = n(m)), a(s["must-revalidate"]) && (i.mustRevalidate = true), a(s["must-understand"]) && (i.mustUnderstand = true), a(s["no-cache"]) && (i.noCache = true), a(s["no-store"]) && (i.noStore = true), a(s["no-transform"]) && (i.noTransform = true), a(s["only-if-cached"]) && (i.onlyIfCached = true), a(s.private) && (i.private = true), a(s["proxy-revalidate"]) && (i.proxyRevalidate = true), a(s.public) && (i.public = true), t(p) && (i.sMaxAge = n(p)), t(f) && (i.staleIfError = n(f)), t(c) && (i.staleWhileRevalidate = n(c)), i;
}

// node_modules/fast-defer/dist/index.mjs
var r2 = Symbol();
function e2() {
  var e3, n2, o2 = new Promise(function(r4, o3) {
    e3 = r4, n2 = o3;
  });
  return o2.resolve = e3, o2.reject = n2, o2[r2] = 1, o2;
}

// node_modules/object-code/dist/index.mjs
function t2(t3, r4) {
  return t3 > r4 ? 1 : -1;
}
function r3(o2, e3) {
  var n2 = 5381;
  if ("object" == typeof o2 && null !== o2 && (o2.toString === Object.prototype.toString || o2.toString === Array.prototype.toString)) {
    e3 || (e3 = /* @__PURE__ */ new WeakSet());
    for (var i = Object.keys(o2).sort(t2), a2 = 0; a2 < i.length; a2++) {
      var c = i[a2], g = o2[c];
      if (n2 = 33 * n2 ^ r3(c, e3), "object" == typeof g && null !== g && (o2.toString === Object.prototype.toString || o2.toString === Array.prototype.toString)) {
        if (e3.has(g)) continue;
        e3.add(g);
      }
      n2 = 33 * n2 ^ r3(g, e3);
    }
    return 33 * n2 ^ r3(o2.constructor, e3);
  }
  var p = typeof o2;
  try {
    o2 instanceof Date ? p += o2.getTime() : p += String(o2);
  } catch (t3) {
    p += String(Object.assign({}, o2));
  }
  for (var f = 0; f < p.length; f++) n2 = 33 * n2 ^ p.charCodeAt(f);
  return n2;
}

// node_modules/axios-cache-interceptor/dist/index.modern.js
var Header = {
  /**
   * ```txt
   * If-Modified-Since: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT
   * ```
   *
   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since
   */
  IfModifiedSince: "if-modified-since",
  /**
   * ```txt
   * Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT
   * ```
   *
   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified
   */
  LastModified: "last-modified",
  /**
   * ```txt
   * If-None-Match: "<etag_value>"
   * If-None-Match: "<etag_value>", "<etag_value>", â€¦
   * If-None-Match: *
   * ```
   *
   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match
   */
  IfNoneMatch: "if-none-match",
  /**
   * ```txt
   * Cache-Control: max-age=604800
   * ```
   *
   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control
   */
  CacheControl: "cache-control",
  /**
   * ```txt
   * Pragma: no - cache;
   * ```
   *
   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Pragma
   */
  Pragma: "pragma",
  /**
   * ```txt
   * ETag: W / '<etag_value>';
   * ETag: '<etag_value>';
   * ```
   *
   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag
   */
  ETag: "etag",
  /**
   * ```txt
   * Expires: <http-date>
   * ```
   *
   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires
   */
  Expires: "expires",
  /**
   * ```txt
   * Age: <delta-seconds>
   * ```
   *
   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Age
   */
  Age: "age",
  /**
   * Used internally as metadata to mark the cache item as revalidatable and enabling
   * stale cache state Contains a string of ASCII characters that can be used as ETag for
   * `If-Match` header Provided by user using `cache.etag` value.
   *
   * ```txt
   * X-Axios-Cache-Etag: "<etag_value>"
   * ```
   */
  XAxiosCacheEtag: "x-axios-cache-etag",
  /**
   * Used internally as metadata to mark the cache item as revalidatable and enabling
   * stale cache state may contain `'use-cache-timestamp'` if `cache.modifiedSince` is
   * `true`, otherwise will contain a date from `cache.modifiedSince`. If a date is
   * provided, it can be used for `If-Modified-Since` header, otherwise the cache
   * timestamp can be used for `If-Modified-Since` header.
   *
   * ```txt
   * X-Axios-Cache-Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT
   * X-Axios-Cache-Last-Modified: use-cache-timestamp
   * ```
   */
  XAxiosCacheLastModified: "x-axios-cache-last-modified",
  /**
   * Used internally as metadata to mark the cache item able to be used if the server
   * returns an error. The stale-if-error response directive indicates that the cache can
   * reuse a stale response when any error occurs.
   *
   * ```txt
   * XAxiosCacheStaleIfError: <seconds>
   * ```
   */
  XAxiosCacheStaleIfError: "x-axios-cache-stale-if-error"
};
var defaultHeaderInterpreter = (headers, location) => {
  if (!headers) return "not enough headers";
  const cacheControl = headers[Header.CacheControl];
  if (cacheControl) {
    const cc = o(String(cacheControl));
    if (
      // Header told that this response should not be cached.
      cc.noCache || cc.noStore || // Server side handling private data
      location === "server" && cc.private
    ) {
      return "dont cache";
    }
    if (cc.immutable) {
      return {
        cache: 1e3 * 60 * 60 * 24 * 365
      };
    }
    if (cc.maxAge !== void 0) {
      const age = headers[Header.Age];
      return {
        cache: age ? (
          // If age is present, we must subtract it from maxAge
          (cc.maxAge - Number(age)) * 1e3
        ) : cc.maxAge * 1e3,
        // Already out of date, must be requested again
        stale: (
          // I couldn't find any documentation about who should be used, as they
          // are not meant to overlap each other. But, as we cannot request in the
          // background, as the stale-while-revalidate says, and we just increase
          // its staleTtl when its present, max-stale is being preferred over
          // stale-while-revalidate.
          cc.maxStale !== void 0 ? cc.maxStale * 1e3 : cc.staleWhileRevalidate !== void 0 ? cc.staleWhileRevalidate * 1e3 : void 0
        )
      };
    }
  }
  const expires = headers[Header.Expires];
  if (expires) {
    const milliseconds = Date.parse(String(expires)) - Date.now();
    return milliseconds >= 0 ? {
      cache: milliseconds
    } : "dont cache";
  }
  return "not enough headers";
};
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t3 = arguments[e3];
      for (var r4 in t3) ({}).hasOwnProperty.call(t3, r4) && (n2[r4] = t3[r4]);
    }
    return n2;
  }, _extends.apply(null, arguments);
}
async function testCachePredicate(response, predicate) {
  if (typeof predicate === "function") {
    return predicate(response);
  }
  const {
    statusCheck,
    responseMatch,
    containsHeaders
  } = predicate;
  if (statusCheck && !await statusCheck(response.status) || responseMatch && !await responseMatch(response)) {
    return false;
  }
  if (containsHeaders) {
    for (const [header, _predicate] of Object.entries(containsHeaders)) {
      var _response$headers$hea;
      if (!await _predicate(
        // Avoid bugs in case the header is not in lower case
        (_response$headers$hea = response.headers[header.toLowerCase()]) != null ? _response$headers$hea : response.headers[header]
      )) {
        return false;
      }
    }
  }
  return true;
}
function regexOrStringMatch(matchPattern, configUrl) {
  if (matchPattern instanceof RegExp) {
    matchPattern.lastIndex = 0;
    return matchPattern.test(configUrl);
  }
  return configUrl.includes(matchPattern);
}
function createValidateStatus(oldValidate) {
  return oldValidate ? (status) => oldValidate(status) || status === 304 : (status) => status >= 200 && status < 300 || status === 304;
}
function isMethodIn(requestMethod = "get", methodList = []) {
  requestMethod = requestMethod.toLowerCase();
  return methodList.some((method) => method === requestMethod);
}
function updateStaleRequest(cache, config) {
  config.headers || (config.headers = {});
  const {
    etag,
    modifiedSince
  } = config.cache;
  if (etag) {
    var _cache$data;
    const etagValue = etag === true ? (_cache$data = cache.data) == null ? void 0 : _cache$data.headers[Header.ETag] : etag;
    if (etagValue) {
      config.headers[Header.IfNoneMatch] = etagValue;
    }
  }
  if (modifiedSince) {
    config.headers[Header.IfModifiedSince] = modifiedSince === true ? (
      // If last-modified is not present, use the createdAt timestamp
      cache.data.headers[Header.LastModified] || new Date(cache.createdAt).toUTCString()
    ) : modifiedSince.toUTCString();
  }
}
function createCacheResponse(response, previousCache) {
  if (response.status === 304 && previousCache) {
    response.cached = true;
    response.data = previousCache.data;
    response.status = previousCache.status;
    response.statusText = previousCache.statusText;
    response.headers = _extends({}, previousCache.headers, response.headers);
    return previousCache;
  }
  return {
    data: response.data,
    status: response.status,
    statusText: response.statusText,
    headers: response.headers
  };
}
function defaultRequestInterceptor(axios) {
  const onFulfilled = async (config) => {
    config.id = axios.generateKey(config);
    if (config.cache === false) {
      return config;
    }
    config.cache = _extends({}, axios.defaults.cache, config.cache);
    if (typeof config.cache.cachePredicate === "object" && config.cache.cachePredicate.ignoreUrls && config.url) {
      for (const url of config.cache.cachePredicate.ignoreUrls) {
        if (regexOrStringMatch(url, config.url)) {
          return config;
        }
      }
    }
    if (typeof config.cache.cachePredicate === "object" && config.cache.cachePredicate.allowUrls && config.url) {
      let matched = false;
      for (const url of config.cache.cachePredicate.allowUrls) {
        if (regexOrStringMatch(url, config.url)) {
          matched = true;
          break;
        }
      }
      if (!matched) {
        return config;
      }
    }
    if (config.cache.cacheTakeover) {
      var _config$headers, _Header$CacheControl, _config$headers$_Head, _config$headers2, _Header$Pragma, _config$headers2$_Hea, _config$headers3, _Header$Expires, _config$headers3$_Hea;
      (_config$headers$_Head = (_config$headers = config.headers)[_Header$CacheControl = Header.CacheControl]) != null ? _config$headers$_Head : _config$headers[_Header$CacheControl] = "no-cache, no-store, must-revalidate";
      (_config$headers2$_Hea = (_config$headers2 = config.headers)[_Header$Pragma = Header.Pragma]) != null ? _config$headers2$_Hea : _config$headers2[_Header$Pragma] = "no-cache";
      (_config$headers3$_Hea = (_config$headers3 = config.headers)[_Header$Expires = Header.Expires]) != null ? _config$headers3$_Hea : _config$headers3[_Header$Expires] = "0";
    }
    if (!isMethodIn(config.method, config.cache.methods)) {
      return config;
    }
    let cache = await axios.storage.get(config.id, config);
    const overrideCache = config.cache.override;
    ignoreAndRequest: if (cache.state === "empty" || cache.state === "stale" || cache.state === "must-revalidate" || overrideCache) {
      if (axios.waiting.has(config.id) && !overrideCache) {
        cache = await axios.storage.get(config.id, config);
        if (cache.state !== "empty" && cache.state !== "must-revalidate") {
          break ignoreAndRequest;
        }
      }
      const def = e2();
      axios.waiting.set(config.id, def);
      def.catch(() => void 0);
      await axios.storage.set(config.id, {
        state: "loading",
        previous: overrideCache ? (
          // Simply determine if the request is stale or not
          // based if it had previous data or not
          cache.data ? "stale" : "empty"
        ) : (
          // Typescript doesn't know that cache.state here can only be 'empty' or 'stale'
          cache.state
        ),
        data: cache.data,
        // If the cache is empty and asked to override it, use the current timestamp
        createdAt: overrideCache && !cache.createdAt ? Date.now() : cache.createdAt
      }, config);
      if (cache.state === "stale" || cache.state === "must-revalidate") {
        updateStaleRequest(cache, config);
      }
      config.validateStatus = createValidateStatus(config.validateStatus);
      if (cache.state === "stale" || cache.data && cache.state !== "must-revalidate") {
        await (config.cache.hydrate == null ? void 0 : config.cache.hydrate(cache));
      }
      return config;
    }
    let cachedResponse;
    if (cache.state === "loading") {
      const deferred = axios.waiting.get(config.id);
      if (!deferred) {
        if (cache.data) {
          await (config.cache.hydrate == null ? void 0 : config.cache.hydrate(cache));
        }
        return config;
      }
      try {
        await deferred;
        const state = await axios.storage.get(config.id, config);
        if (!state.data) {
          if (false) ;
          return onFulfilled(config);
        }
        cachedResponse = state.data;
      } catch (err) {
        if (cache.data) {
          await (config.cache.hydrate == null ? void 0 : config.cache.hydrate(cache));
        }
        return onFulfilled(config);
      }
    } else {
      cachedResponse = cache.data;
    }
    config.transformResponse = void 0;
    config.adapter = function cachedAdapter() {
      return Promise.resolve({
        config,
        data: cachedResponse.data,
        headers: cachedResponse.headers,
        status: cachedResponse.status,
        statusText: cachedResponse.statusText,
        cached: true,
        stale: cache.previous === "stale",
        id: config.id
      });
    };
    return config;
  };
  return {
    onFulfilled
  };
}
async function updateCache(storage, data, cacheUpdater) {
  if (typeof cacheUpdater === "function") {
    return cacheUpdater(data);
  }
  for (const [cacheKey, updater] of Object.entries(cacheUpdater)) {
    if (updater === "delete") {
      await storage.remove(cacheKey, data.config);
      continue;
    }
    const value = await storage.get(cacheKey, data.config);
    if (value.state === "loading") {
      continue;
    }
    const newValue = await updater(value, data);
    if (newValue === "delete") {
      await storage.remove(cacheKey, data.config);
      continue;
    }
    if (newValue !== "ignore") {
      await storage.set(cacheKey, newValue, data.config);
    }
  }
}
function defaultResponseInterceptor(axios) {
  const rejectResponse = async (responseId, config, clearCache) => {
    if (clearCache) {
      await axios.storage.remove(responseId, config);
    }
    const deferred = axios.waiting.get(responseId);
    if (deferred) {
      deferred.reject();
      axios.waiting.delete(responseId);
    }
  };
  const onFulfilled = async (response) => {
    var _response$cached;
    if (!(response != null && response.config)) {
      throw response;
    }
    response.id = response.config.id;
    (_response$cached = response.cached) != null ? _response$cached : response.cached = false;
    const config = response.config;
    const cacheConfig = config.cache;
    if (response.cached) {
      return response;
    }
    if (!cacheConfig) {
      response.cached = false;
      return response;
    }
    if (cacheConfig.update) {
      await updateCache(axios.storage, response, cacheConfig.update);
    }
    if (!isMethodIn(config.method, cacheConfig.methods)) {
      return response;
    }
    const cache = await axios.storage.get(response.id, config);
    if (
      // If the request interceptor had a problem or it wasn't cached
      cache.state !== "loading"
    ) {
      return response;
    }
    if (
      // For 'loading' values (previous: stale), this check already ran in the past.
      !cache.data && !await testCachePredicate(response, cacheConfig.cachePredicate)
    ) {
      await rejectResponse(response.id, config, true);
      return response;
    }
    for (const header of Object.keys(response.headers)) {
      if (header.startsWith("x-axios-cache")) {
        delete response.headers[header];
      }
    }
    if (cacheConfig.etag && cacheConfig.etag !== true) {
      response.headers[Header.XAxiosCacheEtag] = cacheConfig.etag;
    }
    if (cacheConfig.modifiedSince) {
      response.headers[Header.XAxiosCacheLastModified] = cacheConfig.modifiedSince === true ? "use-cache-timestamp" : cacheConfig.modifiedSince.toUTCString();
    }
    let ttl = cacheConfig.ttl || -1;
    let staleTtl;
    if (cacheConfig.interpretHeader) {
      const expirationTime = axios.headerInterpreter(response.headers, axios.location);
      if (expirationTime === "dont cache") {
        await rejectResponse(response.id, config, true);
        return response;
      }
      if (expirationTime !== "not enough headers") {
        if (typeof expirationTime === "number") {
          ttl = expirationTime;
        } else {
          ttl = expirationTime.cache;
          staleTtl = expirationTime.stale;
        }
      }
    }
    const data = createCacheResponse(response, cache.data);
    if (typeof ttl === "function") {
      ttl = await ttl(response);
    }
    if (cacheConfig.staleIfError) {
      response.headers[Header.XAxiosCacheStaleIfError] = String(ttl);
    }
    const newCache = {
      state: "cached",
      ttl,
      staleTtl,
      createdAt: Date.now(),
      data
    };
    await axios.storage.set(response.id, newCache, config);
    const waiting = axios.waiting.get(response.id);
    if (waiting) {
      waiting.resolve();
      axios.waiting.delete(response.id);
    }
    return response;
  };
  const onRejected = async (error) => {
    if (!error.isAxiosError || !error.config) {
      throw error;
    }
    const config = error.config;
    const id = config.id;
    const cacheConfig = config.cache;
    const response = error.response;
    if (!cacheConfig || !id) {
      throw error;
    }
    if (!isMethodIn(config.method, cacheConfig.methods)) {
      await rejectResponse(id, config, true);
      throw error;
    }
    const cache = await axios.storage.get(id, config);
    if (
      // This will only not be loading if the interceptor broke
      cache.state !== "loading" || cache.previous !== "stale"
    ) {
      await rejectResponse(
        id,
        config,
        // Do not clear cache if this request is cached, but the request was cancelled before returning the cached response
        error.code !== "ERR_CANCELED" || error.code === "ERR_CANCELED" && cache.state !== "cached"
      );
      throw error;
    }
    if (cacheConfig.staleIfError) {
      const cacheControl = String(response == null ? void 0 : response.headers[Header.CacheControl]);
      const staleHeader = cacheControl && o(cacheControl).staleIfError;
      const staleIfError = typeof cacheConfig.staleIfError === "function" ? await cacheConfig.staleIfError(response, cache, error) : cacheConfig.staleIfError === true && staleHeader ? staleHeader * 1e3 : cacheConfig.staleIfError;
      if (staleIfError === true || // staleIfError is the number of seconds that stale is allowed to be used
      typeof staleIfError === "number" && cache.createdAt + staleIfError > Date.now()) {
        await axios.storage.set(id, {
          state: "stale",
          createdAt: Date.now(),
          data: cache.data
        }, config);
        const waiting = axios.waiting.get(id);
        if (waiting) {
          waiting.resolve();
          axios.waiting.delete(id);
        }
        return {
          cached: true,
          stale: true,
          config,
          id,
          data: cache.data.data,
          headers: cache.data.headers,
          status: cache.data.status,
          statusText: cache.data.statusText
        };
      }
    }
    await rejectResponse(id, config, true);
    throw error;
  };
  return {
    onFulfilled,
    onRejected
  };
}
var isStorage = (obj) => !!obj && !!obj["is-storage"];
function hasUniqueIdentifierHeader(value) {
  const headers = value.data.headers;
  return Header.ETag in headers || Header.LastModified in headers || Header.XAxiosCacheEtag in headers || Header.XAxiosCacheLastModified in headers;
}
function mustRevalidate(value) {
  return String(value.data.headers[Header.CacheControl]).includes("must-revalidate");
}
function canStale(value) {
  if (hasUniqueIdentifierHeader(value)) {
    return true;
  }
  return value.state === "cached" && value.staleTtl !== void 0 && // Only allow stale values after the ttl is already in the past and the staleTtl is in the future.
  // In cases that just createdAt + ttl > Date.now(), isn't enough because the staleTtl could be <= 0.
  // This logic only returns true when Date.now() is between the (createdAt + ttl) and (createdAt + ttl + staleTtl).
  // Following the example below:
  // |--createdAt--:--ttl--:---staleTtl--->
  // [        past        ][now is in here]
  Math.abs(Date.now() - (value.createdAt + value.ttl)) <= value.staleTtl;
}
function isExpired(value) {
  return value.ttl !== void 0 && value.createdAt + value.ttl <= Date.now();
}
function buildStorage({
  set,
  find,
  remove,
  clear
}) {
  return {
    //@ts-expect-error - we don't want to expose this
    "is-storage": 1,
    set,
    remove,
    clear,
    get: async (key, config) => {
      let value = await find(key, config);
      if (!value) {
        return {
          state: "empty"
        };
      }
      if (value.state === "empty" || value.state === "loading" || value.state === "must-revalidate") {
        return value;
      }
      if (value.state === "cached") {
        if (!isExpired(value)) {
          return value;
        }
        if (!canStale(value)) {
          await remove(key, config);
          return {
            state: "empty"
          };
        }
        value = {
          state: "stale",
          createdAt: value.createdAt,
          data: value.data,
          ttl: value.staleTtl !== void 0 ? value.staleTtl + value.ttl : void 0
        };
        await set(key, value, config);
        if (mustRevalidate(value)) {
          return _extends({}, value, {
            state: "must-revalidate"
          });
        }
      }
      if (!isExpired(value)) {
        return value;
      }
      if (hasUniqueIdentifierHeader(value)) {
        return value;
      }
      await remove(key, config);
      return {
        state: "empty"
      };
    }
  };
}
var clone = (
  // https://caniuse.com/mdn-api_structuredclone (10/18/2023 92.51%)
  typeof structuredClone === "function" ? structuredClone : (value) => JSON.parse(JSON.stringify(value))
);
function buildMemoryStorage(cloneData = false, cleanupInterval = false, maxEntries = false) {
  const storage = buildStorage({
    set: (key, value) => {
      if (maxEntries) {
        let keys = Object.keys(storage.data);
        if (keys.length >= maxEntries) {
          storage.cleanup();
          keys = Object.keys(storage.data);
          while (keys.length >= maxEntries) {
            delete storage.data[keys.shift()];
          }
        }
      }
      storage.data[key] = cloneData === "double" ? clone(value) : value;
    },
    remove: (key) => {
      delete storage.data[key];
    },
    find: (key) => {
      const value = storage.data[key];
      return cloneData && value !== void 0 ? clone(value) : value;
    },
    clear: () => {
      storage.data = /* @__PURE__ */ Object.create(null);
    }
  });
  storage.data = /* @__PURE__ */ Object.create(null);
  storage.cleanup = () => {
    const keys = Object.keys(storage.data);
    let i = -1;
    let value;
    let key;
    while (++i < keys.length) {
      key = keys[i];
      value = storage.data[key];
      if (value.state === "empty") {
        storage.remove(key);
        continue;
      }
      if (value.state === "cached" && isExpired(value) && !canStale(value)) {
        storage.remove(key);
      }
    }
  };
  if (cleanupInterval) {
    storage.cleaner = setInterval(storage.cleanup, cleanupInterval);
  }
  return storage;
}
var SLASHES_REGEX = /^\/|\/$/g;
function buildKeyGenerator(generator) {
  return (request) => {
    if (request.id) {
      return request.id;
    }
    const key = generator(request);
    if (typeof key === "string" || typeof key === "number") {
      return `${key}`;
    }
    return `${r3(key)}`;
  };
}
var defaultKeyGenerator = buildKeyGenerator(({
  baseURL,
  url,
  method,
  params,
  data
}) => {
  if (baseURL !== void 0) {
    baseURL = baseURL.replace(SLASHES_REGEX, "");
  } else {
    baseURL = "";
  }
  if (url !== void 0) {
    url = url.replace(SLASHES_REGEX, "");
  } else {
    url = "";
  }
  if (method !== void 0) {
    method = method.toLowerCase();
  } else {
    method = "get";
  }
  return {
    url: baseURL + (baseURL && url ? "/" : "") + url,
    params,
    method,
    data
  };
});
function setupCache(axios, options = {}) {
  var _options$ttl, _options$etag, _options$modifiedSinc, _options$interpretHea, _options$cacheTakeove, _options$staleIfError, _options$override, _options$hydrate;
  const axiosCache = axios;
  if (axiosCache.defaults.cache) {
    throw new Error("setupCache() should be called only once");
  }
  axiosCache.location = typeof window === "undefined" ? "server" : "client";
  axiosCache.storage = options.storage || buildMemoryStorage();
  if (!isStorage(axiosCache.storage)) {
    throw new Error("Use buildStorage() function");
  }
  axiosCache.waiting = options.waiting || /* @__PURE__ */ new Map();
  axiosCache.generateKey = options.generateKey || defaultKeyGenerator;
  axiosCache.headerInterpreter = options.headerInterpreter || defaultHeaderInterpreter;
  axiosCache.requestInterceptor = options.requestInterceptor || defaultRequestInterceptor(axiosCache);
  axiosCache.responseInterceptor = options.responseInterceptor || defaultResponseInterceptor(axiosCache);
  axiosCache.debug = options.debug || function noop() {
  };
  axiosCache.defaults.cache = {
    update: options.update || {},
    ttl: (_options$ttl = options.ttl) != null ? _options$ttl : 1e3 * 60 * 5,
    // Although RFC 7231 also marks POST as cacheable, most users don't know that
    // and may have problems about why their "create X" route not working.
    methods: options.methods || ["get", "head"],
    cachePredicate: options.cachePredicate || {
      // All cacheable status codes defined in RFC 7231
      statusCheck: (status) => [200, 203, 300, 301, 302, 404, 405, 410, 414, 501].includes(status)
    },
    etag: (_options$etag = options.etag) != null ? _options$etag : true,
    // This option is going to be ignored by servers when ETag is enabled
    // Checks strict equality to false to avoid undefined-ish values
    modifiedSince: (_options$modifiedSinc = options.modifiedSince) != null ? _options$modifiedSinc : options.etag === false,
    interpretHeader: (_options$interpretHea = options.interpretHeader) != null ? _options$interpretHea : true,
    cacheTakeover: (_options$cacheTakeove = options.cacheTakeover) != null ? _options$cacheTakeove : true,
    staleIfError: (_options$staleIfError = options.staleIfError) != null ? _options$staleIfError : true,
    override: (_options$override = options.override) != null ? _options$override : false,
    hydrate: (_options$hydrate = options.hydrate) != null ? _options$hydrate : void 0
  };
  axiosCache.interceptors.request.use(axiosCache.requestInterceptor.onFulfilled, axiosCache.requestInterceptor.onRejected);
  axiosCache.interceptors.response.use(axiosCache.responseInterceptor.onFulfilled, axiosCache.responseInterceptor.onRejected);
  return axiosCache;
}
function buildWebStorage(storage, prefix = "axios-cache-") {
  return buildStorage({
    clear: () => {
      for (const key in storage) {
        if (key.startsWith(prefix)) {
          storage.removeItem(key);
        }
      }
    },
    find: (key) => {
      const json = storage.getItem(prefix + key);
      return json ? JSON.parse(json) : void 0;
    },
    remove: (key) => {
      storage.removeItem(prefix + key);
    },
    set: (key, value) => {
      const save = () => storage.setItem(prefix + key, JSON.stringify(value));
      try {
        return save();
      } catch (_unused) {
        const allValues = Object.entries(storage).filter((item) => item[0].startsWith(prefix)).map((item) => [item[0], JSON.parse(item[1])]);
        for (const _value of allValues) {
          if (_value[1].state === "cached" && isExpired(_value[1]) && !canStale(_value[1])) {
            storage.removeItem(_value[0]);
          }
        }
        try {
          return save();
        } catch (_unused2) {
          const sortedItems = allValues.sort((a2, b) => (a2[1].createdAt || 0) - (b[1].createdAt || 0));
          for (const item of sortedItems) {
            storage.removeItem(item[0]);
            try {
              return save();
            } catch (_unused3) {
            }
          }
        }
        storage.removeItem(prefix + key);
      }
    }
  });
}
export {
  Header,
  buildKeyGenerator,
  buildMemoryStorage,
  buildStorage,
  buildWebStorage,
  canStale,
  createCacheResponse,
  createValidateStatus,
  defaultHeaderInterpreter,
  defaultKeyGenerator,
  defaultRequestInterceptor,
  defaultResponseInterceptor,
  isExpired,
  isMethodIn,
  isStorage,
  mustRevalidate,
  regexOrStringMatch,
  setupCache,
  testCachePredicate,
  updateCache,
  updateStaleRequest
};
/*! Bundled license information:

axios-cache-interceptor/dist/index.modern.js:
  (*!
   * Axios Cache Interceptor 1.8.3
   * (c) 2021-present Arthur Fiorette & Contributors
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=axios-cache-interceptor.js.map
